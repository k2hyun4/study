# 01. PK 컬럼 순서, 대충 하지 말자
* 인덱스 구성시 의도하지 않은 순서의 Primary Key Unique Index가 생성되어 성능저하 유발
## PK 구성과 인덱스 이용
* pk를 조합한 index에 대해, Where 절에서 앞 순서의 pk가 호출되지 않으면 index를 활용하지 않음
* 불필요한 인덱스가 많으면 입력,수정,삭제 시 성능 저하

# 02. 식별자관계와 비식별자관계 설정, 이것만은 알고 해야
## 식별자 관계
* 실선
* 자식이 부모의 키를 자신의 키로 가지는 관계
* 부모자식 관계가 늘어날수록 자식의 pk가 늘어남

## 비식별자 관계
* 점선
* 자식이 부모의 키를 자신의 일반 속성으로 가지는 
* 해당값을 가져오려면 그걸 가진 부모까지 join해서 가져와야 함

## 비식별자관계를 선정하는 기준
* 관계분석
* 약한 관계인지?
* 자식테이블 독립 PK 필요?
* SQL 복잡도 증가 개발생산성 저하?

# 03. 이력 유형 데이터 모델링, 이렇게 하라
* 자주 변경되는 칼럼의 이력만을 관리하는 방법 고려
* "최신여부" 등의 기능성 칼럼도 괜찮
## 내부 스냅샷 이력
* 테이블 1개
* 이력 적을 때 용이

## 1:M 전체 이력
* 테이블 현재1, 현재+과거1
* 관리 항목 증가
* 현재 데이터 중복

## 1:M 과거 이력
* 테이블 현재1, 과거1
* 관리 항목 증가
* 현재+과거 조회시 불편

# 04. 엔티티타입, 통합할 것인가 분리할 것인가
## 엔티티 통합 장점
* 조인 줄어듬
* 복잡도 낮아짐
* 유지보수 횟수 줄어듬...?(더 짜증나던데)

## 엔티티 통합 단점
* 트랜잭션 집중, 데이터량 증가로 인한 성능 저하
* 컬럼별 제약 조건 관리가 복잡해짐
* 관계 파악이 어려워져 업무 이해도 나빠짐

## 통합과 분리, 선택의 기준
* 논리적 데이터 모델링 단계에서 엔티티 타입을 가능한 상세하게 고려
* 조인 vs 데이터 집약 정도를 고려
* 데이터량과 트랜잭션 빈도가 많지 않은 경우엔 통합하여 단순화

# 05. Primary Key와 Unique Index 논쟁에 대하여
## Unique Index만 사용할 경우...
* 모델 관계 파악이 어려움
* key가 null일수도 있음(따로 NotNull 설정해줘야 함)
* 데이터 무결성이 깨질 가능성이 있음
* 좋을 것 없다. 무조건 pk 써라

# 06. 자기참조관계 모델링 기법
## 장점
* join을 줄임
* 추후 관계 사이에 변경될 때 크게 소스를 건들이지 않아도 된다?

## 포인트
* 관계의 연결이 되는 속성에 인덱스를 설정하라
* 오라클의 경우 Start with, connect by 를 활용!

# 07. 엔티티타입, 이렇게 도출하라
## 엔티티 도출 방법
* 명사형 도출 : 문서에서 명사를 추출한 뒤 광범위한 것, 속성 등을 제거
* 정규화 이용 : 어렵...
* 엔티티타입 구분에 의한 4-STEP 데이터 모델링 : 구조 → 업무 흐름 → 기술적 모델링 → 검토

## 도출한 엔티티타입 검증하기
* CRUD Matrix 활용

# 08. 데이터 모델링에서 관계의 중요성
* 업무의 구조와 흐름 파악을 위해
* 불필요한 pk 방지

## 모든 엔티티타입에 관계를?
* 일반적으론 맞음. 관계가 있어야 의미가 부여됨

### 예외사항
* 코드성 엔티티타입 : 수많은 테이블에 연결되어야 함
* 통계성 엔티티타입 : 데이터가 나중에 생성됨에도 부모처럼 관계가 되어버리므로
* 다른 시스템의 엔티티타입을 참조하거나 

# 09. 용어사전과 도메인을 정의하라
* 데이터 타입과 길이가 다르면 join시 인덱스 활용도가 저하됨

# 10. 데이터 모델을 검증하라
## 검증 시의 관점
* 사용자 요구사항과 대비
* 엔티티 타입간의 관계와 업무절차의 부합성

## 체크리스트
### 엔티티타입 검토
* pk에 대한 검증(유일성, 순서)
* 엔티티간의 통합/분리 여부
* 추가/제거할 엔티티 체크

### 속성 검토
* 반정규화?
* 동일 의미를 가지는 속성들의 일치도(이름, 타입, 크기)
* 전후 레코드 간 영향력?

### 관계 검토
* 업무적 흐름과의 일치도

### 도메인/용어 검토

## 기타
* 인터페이스 명세서를 근거로 검증하는 것도 도움이 

# 11. 논리/물리 데이터 모델을 생성하라
## 논리 데이터 모델
* 목적 : 비즈니스 형상화
* 모토 : 어떻게 하면 업무를 모델로 가장 잘 표현할까?
* 시기 : 분석단계

### 논리적 데이터 모델이 없으면?
* 데이터 모델의 확장성을 확보할 수 없음(업무적으로 특성있는 엔티티가 다른 엔티티에 묻힐 수 있음)

## 물리 데이터 모델
* 목적 : 실제 데이터베이스에 탑재하기 위한 제반 사항을 설계
* 시기 : 분석 이후 설계 단계

## 논리에서 물리로 변환하기
### ERD 전환
* ERD를 테이블 관계도로 전환
* 반정규화
* 무결성 고려

### 물리설계
* 트랜잭션 설계
* 뷰 생성
* 접근 방법 고려
* 인덱스 생성

### 분산설계
* 분산 데이터베이스가 필요할 경우 설계

# 12. 데이터 독립성의 실무 적용
## 데이터 독립성을 재정한 이유?
* [DB에 대한 사용자의 view] 와 [DB가 실제 표현되는 View]를 분리하여 변경에 따른 간섭을 줄이기 위해
* 단계별 Schema에 따라 DDL, DML이 달라짐

## ANSI 표준 모델이 제시하는 3단계 구성의 데이터 독립성 모델
### 외부 단계(View)
* 사용자 개개인이 보는 자료에 대한 관점과 관련
* 외부 스키마 : DB의 개개 사용자나 응용프로그래머가 접근하는 DB 정의

### 개념적 단계(Table)
* 사용자가 처리하는 데이터 유형의 공통적인 사항을 처리
* 모든 사용자 관점을 통합한 조직 전체의 DB를 기술하는 것

### 내부적 단계(실제 DB에 저장된 Table..?)
* 물리적 장치에서 데이터가 실제적으로 저장되는 방법을 표현

## 논리적 독립성과 물리적 독립성
### 논리적 독립성
* 개념 스키마가 변경되어도 외부 스키마에 영향을 미치지 않도록 지원하는 것
* 논리적 구조가 변경되어도... ㅇㅋ

### 물리적 독립성
* 내부 스키마가 변경되어도 외부 스키마와 개념 스키마에 영향을 미치지 않도록 지원하는 것
* 저장 장치가 변경되어도... ㅇㅋ

## Mapping
### 외부적/개념적 사상(논리적 사상)
* 외부적 뷰와 개념적 뷰의 상호 관련성을 정의함

### 개념적/내부적 사상(물리적 사상)
* 개념적 뷰와 저장된 데이터베이스의 상호 관련성을 정의함

# 13. 데이터 무결성의 실무 적용
* 트랜잭션 : 업무적으로 의미 있는 논리적인 일의 처리 단위(A Logical Unit of Work)
* 데이터 무결성 : 트랜잭션을 유지시켜주는 최소한의 장치를 엔티티타입, 관계 속성 등에 걸어주고 유지할 수 있도록 하는 것
## 데이터 무결성의 종류
* 엔티티 무결성 : unique, not null
* 참조 무결성 : fk가 참조하는 값은 pk or null
* 속성 무결성 : 기본값, 타입 등의 속성을 지켜야 함
* 사용자 무결성 : 사용자의 의미적 요구사항을 준수해야 함

# 14. 트랜잭션 관리의 실무 적용

# 15. 정규화의 실무 적용

# 16. 성능 데이터 모델링

# 17. 정규화를 통한 데이터베이스 성능 향상

# 18. 반정규화를 통한 데이터베이스 성능 향상

# 19. 데이터 모델 단순화를 통한 데이터베이스 성능 향상

# 20. 테이블 수직/수평분할에 의한 성능 향상

# 21. 수퍼타입/서브타입 모델의 성능 고려 방법

# 22. 인덱스 특성을 고려한 PK/FK 데이터베이스 성능 향상

# 23. 효율적인 채번 방식을 통한 성능 향상

# 24. Foreign Key를 이용할 것인가?

# 25. 데이터베이스 분산 설계를 활용하라

# 26. 데이터베이스 진단의 핵심원리

# 27. 데이터 품질 관리의 이해

# 28. 데이터베이스 전망과 DA/DBA/모델러의 전망
